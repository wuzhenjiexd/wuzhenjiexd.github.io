<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++实现深度学习模型FPGA部署（1）——卷积]]></title>
    <url>%2Fp%2Fa8ba.html</url>
    <content type="text"><![CDATA[C++实现深度学习模型FPGA部署（1）——卷积信号处理中的卷积在信号处理中，经常会对信号进行卷积操作，卷积这个概念最早来源于信号处理中。 假设对于一个线性系统其在单位脉冲δ(t)的响应下，输出为h(t).那么在Aδ(t)的响应下输出为Ah(t).而所有的信号都可以用δ(t)乘以一个系数的和来表示。 即$$u(t)=\int_{-\infty}^{+\infty} u(x) \delta(t-x) d x$$ 上图为两个方波之间的卷积，黑线为卷积之后的结果。 上图为方波与指数衰退脉冲波的卷积。 由于此时卷积的对象只有一维，这种情况可以称为一维卷积。 深度学习中的卷积将卷积的对象从一维推广到二维，就可以实现二维卷积，二维卷积通常用来对图像进行处理。此时我们将卷积所用的滤波器称为卷积核。一些常见的卷积核也被称为算子，比如Robert算子，Sobel算子。与信号处理中不同的是在信号处理上，反转180度称作卷积，直接滑动计算称作自相关，在大部分深度学习框架上都没有反转180度的操作。 对a，b两个二维矩阵的卷积公式可以写为$$c\left(n_{1}, n_{2}\right)=\sum_{k_{1}=-\infty}^{\infty} \sum_{k_{2}=-\infty}^{\infty} a\left(k_{1}, k_{2}\right) b\left(n_{1}-k_{1}, n_{2}-k_{2}\right)$$动态过程如下图所示 C++代码实现根据填充的边界设定不同，BoundaryCondition可选的类型有 zero边界以外的点为0 bound边界以外的点和边界值相等 period边界以外的点和另一边界上的点组成周期信号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;iostream&gt; using namespace std;enum BoundaryCondition&#123; zero ,bound ,period&#125;;enum Method&#123; full ,same ,valid&#125;;//参数设置const int A_Row = 4;const int A_Col = 5;const int B_Row = 2;const int B_Col = 3;BoundaryCondition Bc = zero;Method method = full;float A[A_Row][A_Col] = &#123;&#123;1,2,3,4,5&#125;, &#123;2,3,4,5,6&#125;, &#123;3,4,5,6,7&#125;, &#123;4,5,6,7,8&#125;&#125;;float B[B_Row][B_Col] = &#123;&#123;1,2,1&#125;, &#123;2,3,2&#125;&#125;;float** C = 0;int cR;int cC;template &lt;typename T&gt;T GetA_Ele(int row,int col);template &lt;typename T&gt;void conv(const T a[][A_Col],const T b[][B_Col],T**&amp; c);int main()&#123; conv(A,B,C); for(int i = 0;i &lt; cR;i++) &#123; for(int j = 0;j &lt; cC;j++) cout&lt;&lt;C[i][j]&lt;&lt;"\t"; cout&lt;&lt;endl; &#125; delete[] C;&#125;//计算A和B的卷积 template&lt;typename T&gt;void conv(const T a[][A_Col],const T b[][B_Col],T**&amp; c)&#123; int offsetR = 0; int offsetC = 0; switch(method) &#123; case full: cR = A_Row + B_Row - 1; cC = A_Col + B_Col - 1; break; case same: cR = A_Row; cC = A_Col; offsetR = B_Row/2; offsetC = B_Col/2; break; case valid: cR = A_Row - B_Row + 1; cC = A_Col - B_Col + 1; if((cR &lt; 1)|(cC &lt; 1)) return; offsetR = B_Row - 1; offsetC = B_Col - 1; break; default: return; &#125; c = new T*[cR]; //给二维数组分配空间 for(int i = 0;i &lt; cR;i++) c[i] = new T[cC]; for(int i = 0;i &lt; cR;i++) &#123; for(int j = 0;j &lt; cC;j++) &#123; c[i][j] = 0; for(int k1 = 0;k1 &lt; B_Row;k1++) &#123; for(int k2 = 0;k2 &lt; B_Col;k2++) c[i][j] += b[k1][k2]*GetA_Ele&lt;float&gt;(i - k1 + offsetR,j - k2 + offsetC); &#125; &#125; &#125;&#125;//根据边界条件获取A矩阵的元素template &lt;typename T&gt;T GetA_Ele(int row,int col)&#123; switch(Bc) &#123; case zero: //索引超出界限认为0 if((row &lt; 0)|(row &gt; A_Row)|(col &lt; 0)|(col &gt; A_Col)) return 0; case bound: //超出索引部分和边界值相等 if(row &lt; 0) row = 0; else if(row &gt;= A_Row) row = A_Row - 1; if(col &lt; 0) col = 0; else if(col &gt;= A_Col) col = A_Col - 1; return A[row][col]; case period: while((row &lt; 0)|(row &gt;= A_Row)) &#123; if(row &lt; 0) row += A_Row; else row -= A_Row; &#125; while((col &lt; 0)|(col &gt;= A_Col)) &#123; if(col &lt; 0) col += A_Col; else col -= A_Col; &#125; return A[row][col]; default: return T(0); &#125;&#125;]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>FPGA</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客更新]]></title>
    <url>%2Fp%2F1a1c.html</url>
    <content type="text"><![CDATA[更新内容主要修改内容为 修改网页图标 创建子分类 添加sitemap 修改正文宽度 优化URL 修改网页图标博客主页标签页图标默认为next自带的图像N，可以更换为自己喜欢的图标。 可用的图标素材网站比如iconfont；easyicon 下载16x16以及32x32大小的PNG格式图标，置于/themes/next/source/images/下打开 themes/next/下的_config.yml，查找favicon 1234567favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 修改small，medium对应的图标路径 创建子分类即在首页显示具体的分类菜单，以python举例，需要修改主题配置文件/themes/next/_config.yml，搜索menu，添加想加的分类 12345678menu: home: / categories: /categories/ archives: /archives/ tags: /tags/ python: /categories/python/ # 此处为新添加的菜单 guestbook: /guestbook about: /about/ 此时新菜单的名称是menu.python，需要继续修改language配置，查看站点配置文件的language选项，去/themes/languages/XX.yml找到对应的语言文件，menu处添加一下配置 123456789101112menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 guestbook: 留言 python: python # python菜单显示的名称 添加sitemap以及站点验证添加sitemap站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站 安装插件打开hexo目录下的dos命令行，分别安装百度和google插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 然后在博客目录的_config.yml中添加如下代码 123456自动生成sitemapsitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml 在hexo g之后如果public文件夹下包含sitemap.xml以及baidusitemap.xml两个文件则说明安装正确。 站点验证站点准备首先需要注册百度站长账号以及谷歌账号，以及通过搜索site:www.oneonecity.xyz（更换为自己的网站），如果搜素不到即还未收录。 网站所有权验证百度和谷歌提供了三种方法：文件验证、HTML标签验证和CNAME验证 推荐使用HTML标签验证，三种方法在该博客里有详细介绍。 将该标签（红框中完整的，并非只是后面的token）； 在Next主题配置文件（不是博客配置文件）开启提交百度的选项： 1234# 此处设置成true之后，将themes/next/layout/_partials/head.swig # 下把默认的百度和 google 验证值替换为搜索引擎为你提供的完整HTML标签即可google_site_verification: truebaidu_site_verification: true 修改themes/next/layout/_partials/head.swig，添加从百度获取的完整的HTML验证标签，注意名字的对应！ 123&#123;% if theme.baidu_site_verification %&#125; &lt;meta name=&quot;baidu-site-verification&quot; content=&quot;yourtoken&quot; /&gt;&#123;% endif %&#125; 编译部署你的博客,进入你的博客首页或者任意文章，按F12，如果在head标签中看到了验证标签，就可以了。 点击网站验证按钮，如果过程没问题则会验证成功 sitemap提交提交方式选择使用sitemap提交，此时需要参照创建子分类中提到的方法创建sitemap以及baidusitemap分类，以便搜索引擎爬取。 1234menu: # 新增,命名随意 sitemap: /sitemap.xml || sitemap baidusitemap: /baidusitemap.xml || sitemap 点此&gt;&gt;进入Google Search Console控制台，需要翻墙。点击你的站点，如果没有请先添加站点；然后点击控制台–&gt;抓取–&gt;站点地图，点击右上角添加/测试站点地图按钮，将你的sitemap.xml提交测试，测试成功之后重复该步骤进行添加！ 百度同理。 注意事项由于github禁止百度的爬虫，因此我在提交谷歌sitemap时成功，但是提交百度sitemap时提示抓取失败，通过百度抓取诊断发现移动抓取成功，PC抓取失败。因此在baidusitemap.xml中增加 1234&lt;mobile:mobile/&gt; ：移动网页&lt;mobile:mobile type=&quot;mobile&quot;/&gt; ：移动网页 &lt;mobile:mobile type=&quot;pc,mobile&quot;/&gt;：自适应网页&lt;mobile:mobile type=&quot;htmladapt&quot;/&gt;：代码适配 其中之一通过移动sitemap协议提交sitemap。 修改正文宽度NexT 对于内容的宽度的设定如下： 700px，当屏幕宽度 &lt; 1600px 900px，当屏幕宽度 &gt;= 1600px 移动设备下，宽度自适应 这种设定导致在电脑上阅读博客时留白过多，显得文章过窄。 可以通过修改Hexo/themes/next/source/css/_custom/custom.styl文件（如果没有就新建一个）来达到修改正文宽度的效果。 Mist 和 Muse当你使用在 Mist 和 Muse 风格时增加以下内容： 1234// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px Pisces 和 Gemini当你使用 Pisces 和 Gemini 风格时增加以下内容： 123456789101112131415161718192021222324252627.header&#123; width: 80%; +tablet() &#123; width: 100%; &#125; +mobile() &#123; width: 100%; &#125;&#125;.container .main-inner &#123; width: 80%; +tablet() &#123; width: 100%; &#125; +mobile() &#123; width: 100%; &#125;&#125;.content-wrap &#123; width: calc(100% - 260px); +tablet() &#123; width: 100%; &#125; +mobile() &#123; width: 100%; &#125;&#125; 参考文档： NexT | 修改内容区域的宽度 优化urlseo搜索引擎优化认为，网站的最佳结构是用户从首页点击三次就可以到达任何一个页面，由于默认生成的文章链接格式为:year/:month/:day/:title/，导致层次过多不利于seo，而且可能存在出现中文的情况，可以通过使用hexo-abbrlink这个插件来解决这个问题。 插件安装 npm install hexo-abbrlink --save 修改站点配置文件 1234permalink: post/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 该插件会通过文章的title来计算得到唯一的abbrlink，进而优化url。 npm小知识npm（node package manager）nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等） 使用npm安装插件：npm install &lt;name&gt; [g] [--save -dev] :node 插件名称 -g:全局安装，会在node安装的根目录下载对应的包，在计算机的任何文件都可以使用该插件，默认的node安装目录是：C:\Users\Administrator\AppData\Roaming\npm;如果不带该属性，将会安装在当前目录，下载安装包的位置是当前目录的node_modules文件夹 –save：将配置信息保存在node项目配置文件package.json中 -dev：保存至package.json 的devDependencies节点，如果没有该属性，该插件将会被保存至dependencies节点，devDependencies和dependencies有什么区别呢？其实从名字就应该可以看出来两者的区别，devDependencies中dev是development（开发）的缩写，dependencies是依赖的意思。所以 dependencies 是程序正常运行所需要安装的依赖，而devDependencies是开发所需要的依赖，比如一些单元测试的包~ 为什么要保存至package.json？因为我们使用node的时候需要很多的包，所以我们将我们的配置信息，也就是我们需要包的名称等其他信息保存至一个文件中，如果说其他开发者就可以直接使用一个命令就可以安装和我们相同的配置，这个命令就是npm install，就可以下载package.json 下所有需要的包。npm install –production则只下载dependencies下的包 使用npm卸载插件：npm unstall &lt;name&gt; [-g] [--save-dev] 在npm中要卸载插件不是将文件夹删除就可以了，因为你的配置信息还在package中，所以要使用npm unstall &lt;name&gt; [-g] [--save-dev]命令 删除全部插件:rimraf node_modules（首先你需要先安装rimraf 插件） 更新npm插件：npm update &lt;name&gt; [g] [--save-dev]]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python图片外链替换]]></title>
    <url>%2Fp%2F5735.html</url>
    <content type="text"><![CDATA[图片外链替换之前的图片外链都通过七牛云制作，但是发现七牛云现在只有30天的测试外链，导致之前传的图片30天后就看不到了，所以需要一个替换外链以及上传本地图片的工具。 在挑选过很多厂商的云存储后选择了阿里云的OSS 开通阿里云OSS在使用阿里云OSS之前，需要注册并且实名认证。在OSS 产品详情页，单击立即开通。 开通之后在OSS 产品详情页面单击管理控制台就能直接进入 OSS 管理控制台界面。 开通 OSS 服务后，默认的计费方式是按量付费。也可以购买折扣套餐，我是用于在博客上上传图片因此选择标准存储类型，40GB容量每年也只需要9元。 一般来说40G绰绰有余，可以先试试按量付费再选择。 阿里云OSS可以在网页上直接上传图片获得外链，也可以通过下载OSSBrowser 客户端工具进行上传，由于想自动的完成上传任务，我选择通过用python调用API的方式来实现。 阿里云API首先在控制平台中根据需要创建bucket，然后在用户头像里进入用户AccessKey，获得AccessKey ID和Access Key Secret，调用API前需要先安装oss库pip install oss2，按照以下代码实现上传 123456789101112131415161718192021222324import oss2keyid = 'XX'keysecret = 'YY'auth = oss2.Auth(keyid, keysecret)# Endpoint以北京为例，其它Region请按实际情况填写。Endpoint = 'http://oss-cn-beijing.aliyuncs.com'Bucket_name = 'NAME' # 你命名的Bucket_namehttp = 'https://' +Bucket_name + '.oss-cn-beijing.aliyuncs.com/'bucket = oss2.Bucket(auth, Endpoint, Bucket_name)def up_oss(name, objectname, extension, path, bucket): """ :param extension: 文件拓展名 :param name: 文件保存名 :param path: 本地图片路径 :param bucket: 保存的bucket名 :return: 新的图片外链 """ object_path = 'WZJ_blog/' + objectname + '/' + name + '.' + extension bucket.put_object_from_file(object_path, path) return http + object_path 然后将新的外链替换md文件中旧的本地地址就可以了。 图片上传代码总体思路 读取md文件with open(filepath, &#39;r&#39;, encoding=&#39;utf-8&#39;, errors=&#39;ignore&#39;) as f: contents = f.read() 用正则表达式匹配md文本中图片链接的部分regex = r&#39;!\[.*?\]\((.+?)\)&#39; 判断是否为本地图片，若是则上传获得新图片外链，不是则跳过 在md文本中的旧外链替换为新外链 实现效果运行时带路径命令行参数的情况，完成后自动退出，可以将多个md放在文件夹内将文件夹作为路径参数 运行时不带命令行参数的情况，完成后可继续下一个文件，也可对文件夹内的所有md继续替换。 完整代码完整代码如下，使用时需要将keyid，keysecret，Bucket_name，Endpoint四个内容根据实际情况修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215import sysfrom tkinter import ttkfrom tkinter.filedialog import *import oss2from tqdm import tqdmimport osdef islocal(path): result = os.path.exists(path) return resultdef ismd(path): res = os.path.splitext(path)[-1] == '.md' return resdef readContentInFile(filepath): """ :param filepath: 读取md文件 :return: 返回md文件的字符串 """ with open(filepath, 'r', encoding='utf-8', errors='ignore') as f: contents = f.read() return contentsdef getURLsInFile(filePath): """ :param filePath: 搜索md文件中的图片链接，似乎[]中不写任何东西会漏选 ,将.+换成.* :return: 所有连接的列表 """ content = readContentInFile(filePath) regex = r'!\[.*?\]\((.+?)\)' results = re.findall(regex, content) return resultsdef up_oss(name, objectname, extension, path, bucket): """ :param name: 文件保存名 :param path: 本地图片路径 :param bucket: 保存的bucket名 :return: 新的图片外链 """ object_path = 'WZJ_blog/' + objectname + '/' + name + '.' + extension bucket.put_object_from_file(object_path, path) return http + object_pathdef replaceAllsubStrInFile(filePath, oldStr, newStr): """ :param filePath: md文本路径 :param oldStr: 旧的图片外链 :param newStr: 新的图片外链 :return: """ aFile = open(filePath, 'r', encoding='utf-8', errors='ignore') # 打开所有文件 str = aFile.read() aFile.close() str = str.replace(oldStr, newStr) # 将字符串里前面全部替换为后面 bFile = open(filePath, 'w', encoding='utf-8', errors='ignore') bFile.write(str) # 再写入 bFile.close() # 关闭文件def repalce_url(file): """ :param file: 单个md文件 :return: 整合功能 """ object_name = os.path.split(file)[-1].split('.')[0] url_list = getURLsInFile(file) for url in tqdm(url_list): if islocal(url): save_path = url name = os.path.split(url)[-1].split('.')[0] extension = os.path.split(url)[-1].split('.')[-1] try: url_new = up_oss(name, object_name, extension, save_path, bucket) replaceAllsubStrInFile(file, url, url_new) except: print('上传%s时发生错误' %url) else: print('%s | 该本地路径查询失败，已跳过' %url) print('所有图片链接已替换完毕')def command_run(): file_path = sys.argv[1] if os.path.isfile(file_path): repalce_url(file_path) elif os.path.isdir(file_path): files = [os.path.join(file_path, e) for e in os.listdir(file_path)] for i, f_path in enumerate(files): if ismd(f_path): repalce_url(f_path) print('完成第%s个markdown文件' % (i + 1)) else: print('%s已跳过' % f_path)def GUI_run(): def return_path(): """ :return: 将文件选择框的选择输入到path中 """ choose_path = askopenfilename(title='Select markdown file', filetypes=[('markdown', '*.md'), ('All Files', '*')]) path.set(choose_path) def reutrn_dir(): """ :return: 将文件夹选择框的选择输入到path中 """ dir_path = askdirectory(title='Select dir path') path.set(dir_path) def start_replace(): """ :return: 区分输入单个文件还是文件夹 """ file_path = path.get() if os.path.isfile(file_path): repalce_url(file_path) elif os.path.isdir(file_path): files = [os.path.join(file_path, e) for e in os.listdir(file_path)] for i, f_path in enumerate(files): if ismd(f_path): repalce_url(f_path) print('完成第%s个markdown文件' % (i + 1)) else: print('%s已跳过' % f_path) root = Tk() root.title("外链替换") root.geometry("300x150") frame1 = Frame(root) # 将第一部分整合为一个框架 path = StringVar() ttk.Label( frame1, text="输入路径", font=('times', 12)).pack( side=LEFT, padx=5, pady=5) Button(frame1, text='选择路径', command=return_path, padx=5, pady=5, font=("times", 10) ).pack(side=LEFT) Button(frame1, text='选择文件夹路径', command=reutrn_dir, padx=5, pady=5, font=("times", 10) ).pack(side=LEFT) frame1.pack(side=TOP, padx=10, pady=10) ttk.Entry( root, textvariable=path).pack( side=TOP, fill=X, padx=5, pady=5) Button(root, text='开始替换图片外链', command=start_replace, padx=10, pady=10, font=("times", 10) ).pack(side=LEFT) Button(root, text='Quit', command=root.quit, padx=10, pady=10, font=("times", 10) ).pack(side=RIGHT) root.mainloop()if __name__ == '__main__': # 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录 https://ram.console.aliyun.com 创建RAM账号。 keyid = 'XX' keysecret = 'YY' auth = oss2.Auth(keyid, keysecret) # Endpoint以杭州为例，其它Region请按实际情况填写。 Endpoint = 'http://oss-cn-beijing.aliyuncs.com' Bucket_name = 'NAME' # 你命名的Bucket_name http = 'https://' +Bucket_name + '.oss-cn-beijing.aliyuncs.com/' bucket = oss2.Bucket(auth, Endpoint, Bucket_name) if len(sys.argv) == 1: # 无命令行参数 GUI_run() elif len(sys.argv) == 2: # 带地址参数 if os.path.exists(sys.argv[1]) and os.path.splitext(sys.argv[1])[-1] == '.md': # 路径输入正确 command_run() elif os.path.isdir(sys.argv[1]): command_run() else: print('路径不存在或为非md文件，请退出重输') else: print('参数过多，请检查输入') 其它图库外链转移代码为了以防万一，还写了一个将图片从一个云存储转移到了一个云存储的代码，原理是将图片从一个前云存储上下载下来存在本地，然后进行上传替换，其他部分和图片上传代码差不多。 12345678910111213from urllib.request import urlretrievedef download_img(url): """ name: 图片的保存名 extension： 图片的保存格式 :param url: 单个图片外链 :return: 下载图片至本地以及返回文件名加路径 """ name = os.path.split(url)[-1].split('.')[0] extension = os.path.split(url)[-1].split('.')[-1] # print(name) urlretrieve(url, os.path.join(save.get(), name)+ '.' + extension) return name, extension, os.path.join(save.get(), name) + '.' + extension 效果测试]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>blog</tag>
        <tag>oss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[steam游戏按照MC均分自动分类]]></title>
    <url>%2Fp%2F59e6.html</url>
    <content type="text"><![CDATA[steam游戏分类换了个新电脑，结果发现steam 的游戏分类全没了，顺带连着之前的电脑分类也没了，而且steam的分类太麻烦太反人类了，正好借这个机会尝试一下爬取游戏MC分数来进行分类。 悲报：这个功能下个月的steam正式版就会加入… 步骤1：获取拥有的所有游戏名steam有自己的api，但是使用有些麻烦，获取游戏名这种简单的功能建议使用steamapi。 12345678910import steamapisteamapi.core.APIConnection(api_key="XXX", validate_key=True)# steam官方支持的api需要申请key才能调用# 可以通过http://steamrep.com网站查询64位IDme = steamapi.user.SteamUser(64位ID)for i in range(len(me.games)): print(me.games[i]) 步骤2：爬取游戏名的分数因为是steam游戏的评分，我选择了metacritic的PC版媒体评分，相对公正。而且考虑到”高分信媒体，低分信自己”，对于媒体均分低但是用户评分高的也将单独归为一类。 第一步就是从步骤1中获得游戏的metacritic链接，观察发现游戏的链接格式为https://www.metacritic.com/game/pc加上游戏名字，但是游戏名字转换很麻烦，总结了一下大致要求有 12345678910&gt; # 0. 有'/'隔开的一第一个名字为准&gt; # 1. 全部文字小写&gt; # 2. 将:,&amp;以及空格转换成-&gt; # 3. 罗马数字转换成几个i&gt; # 4. '.'号似乎直接去掉&gt; # 5. ()内有文字的连带()去除&gt; # 6. 去掉所有奇怪的符号&gt; # 7. 去除连续空格以及首尾多余空格&gt; # 8. 去除连续-以及首尾-&gt; 其中在实现7,8的时候发现用re.sub来代替str.replace效果很好 game= re.sub(r&#39;--+&#39;, &#39;-&#39;, game, 0) re.sub的功能re是regular expression的所写，表示正则表达式 sub是substitute的所写，表示替换； re.sub是个正则表达式方面的函数，用来实现通过正则表达式，实现比普通字符串的replace更加强大的替换功能； re.sub共有五个参数。 其中三个必选参数：pattern, repl, string 两个可选参数：count, flags pattern，表示正则中的模式字符串。 repl可以是字符串，也可以是函数。表示被替换对象 string，即表示要被处理，要被替换的那个string字符串。 1234567891011121314import urllib.requestheaders = &#123; 'User-Agent': 'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'&#125; # 不加这个会导致403错误data = Nonereq = urllib.request.Request(url, data, headers)response = urllib.request.urlopen(req)the_page = response.read()html_doc = the_page.decode("utf8") 此时就得到了我们想到的网页的html 但是由于没有学习过html，第一步要先看懂html HTML 标题HTML 标题（Heading）是通过 - 等标签进行定义的。 实例1234&gt; &lt;h1&gt;This is a heading&lt;/h1&gt;&gt; &lt;h2&gt;This is a heading&lt;/h2&gt;&gt; &lt;h3&gt;This is a heading&lt;/h3&gt;&gt; HTML 段落HTML 段落是通过 标签进行定义的。 实例123&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt;&gt; &lt;p&gt;This is another paragraph.&lt;/p&gt;&gt; HTML 链接HTML 链接是通过 标签进行定义的。 实例12&gt; &lt;a href="http://www.w3school.com.cn"&gt;This is a link&lt;/a&gt;&gt; HTML 图像HTML 图像是通过 标签进行定义的。 实例12&gt; &lt;img src="w3school.jpg" width="104" height="142" /&gt;&gt; 解析获得的html，一般有以下几种方法 正则表达式 Beautifulsoup lxml 2,3这两个库都是HTML/XML的处理库，Beautifulsoup纯python实现，效率低，但是功能实用，比如能用通过结果搜索获得某个HTML节点的源码；lxmlC语言编码，高效，支持Xpath 此处我选用了Beautifulsoup,导入json视为了将获得的text转换成字典 1234from bs4 import BeautifulSoupimport jsonsoup = BeautifulSoup(html_doc, 'html.parser')ratingValue = json.loads(soup.find('script', &#123;'type': 'application/ld+json'&#125;).get_text())['aggregateRating']['ratingValue'] 到这一步就获得了游戏对应的评分。 将获得数据写成csv文档，但是csv文档直接用excel打开中文会显示成乱码。 解决步骤： 用记事本打开csv文件，另存为Unicode格式 重新打开excel，执行”数据”-&gt;”自文本”-&gt;选择csv文件-&gt;”导入”-&gt;出现文本导入导向对话框-&gt;”下一步”-&gt;取消Tab键，选中逗号作为分隔符号-&gt;”确定” 到这一步工作就基本完成了。 步骤3：根据信息进行分类steam的游戏分类信息都保存在\Steam\user data{user}\7\remote\sharedconfig.vdf中，建议使用notepad++打开。VDF的全称是Valve Data File，VDF 文件扩展名主要归类于 Game Files 类别，用于安装脚本，可视化元素，资源和配置脚本等。 这是最原始的一个VDF配置， 12345678910111213141516171819202122232425262728293031&quot;UserRoamingConfigStore&quot;&#123; &quot;Software&quot; &#123; &quot;Valve&quot; &#123; &quot;Steam&quot; &#123; &quot;SurveyDate&quot; &quot;2019-06-17&quot; &quot;SurveyDateVersion&quot; &quot;-2861855842901178672&quot; &quot;StartMenuShortcutCheck&quot; &quot;1&quot; &quot;DesktopShortcutCheck&quot; &quot;0&quot; &quot;SteamDefaultDialog&quot; &quot;#app_store&quot; &quot;Apps&quot; &#123; &quot;619150&quot; &#123; &quot;cloudenabled&quot; &quot;1&quot; &#125; &#125; &#125; &#125; &#125; &quot;controller_config&quot; &#123; &quot;619150&quot; &#123; &quot;usetime&quot; &quot;4718.4248046875&quot; &#125; &#125;&#125; 新添加的游戏分类要在Apps按照以下格式修改 12345678910&quot;Apps&quot; &#123; &quot;373480&quot; &#123; &quot;tags&quot; &#123; &quot;0&quot; &quot;test&quot; &#125; &#125;&#125; 其中”373480”表示的游戏的appid， “0” “test”中的“0”表示这是该游戏的第一个分类，”test”表示该分类名字为test。基本上了解这些就可以开始分类了。 123456789101112131415161718192021class game: num = 0 def __init__(self, name, grade): self.name = str(name) self.grade = grade game_add.num += 1 def gen_info(self): info = " " + '"' + self.name + '"' + "\n" # 5个tab,为了好看 info = info + ' &#123;' + "\n" info = info + ' "tags"' + '\n' info = info + " &#123;" + "\n" for i in range(len(self.grade)): info = info + ' ' + '"' + str(i) + '"' + ' ' + '"' + self.grade[ i] + '"' + "\n" info = info + ' &#125;' + '\n' info = info + ' &#125;' return info 之后只要创建这个类的实例，然后把gen_info拼接起来就可以了。 实际效果]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>steam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用pyradiomics提取医学图像中的特征]]></title>
    <url>%2Fp%2F5ee0.html</url>
    <content type="text"><![CDATA[pyradiomics是一个开源的python包，用于提取医学影像上的放射组学特征。 这篇主要讲了pyradiomics的安装以及使用。 安装 确保计算机已经安装了python，且版本在3.4以上 通过python -m pip install pyradiomics进行安装 其他安装方法可以参照官方文档 特征提取命令行运行pyradiomics可以直接在命令行中进行操作，可以对单组图像或者批量图像进行特征提取。 在提取前先确保你有医学影像的nrrd格式文件以及对应的标注轮廓后的Mask文件 nrrd并不是必须的，只要是itk能读取的格式就行（比如NIfTI，MHA，MHD，HDR等） 从单个图像中提取特征 1$ pyradiomics &lt;path/to/image&gt; &lt;path/to/segmentation&gt; 从批量图像中提取特征 1$ pyradiomics &lt;path/to/input&gt; 批量图像处理时的输入为csv文件，其中第一列的标题必须为Image，第二列的标题必须为Mask（大小写敏感）。Image那一列存放的信息为每个图像的存放地址，Msak为mask的存放地址。也可以添加其他列，计算后得到的特征值将存在添加的列后面，添加的列信息保持不变。 所有标题都应该是唯一的，与PyRadiomics（&lt;filter&gt;_&lt;class&gt;_&lt;feature&gt;）提供的标题不同。如果发生冲突，PyRadiomics值会覆盖值。 默认情况下特征值将打印到控制台窗口，如果需要将结果存储csv文件中需要将命令修改为： 12$ pyradiomics &lt;path/to/image&gt; &lt;path/to/segmentation&gt; -o results.csv -f csv$ pyradiomics &lt;path/to/input&gt; -o results.csv -f csv 对于特征提取时的参数选择可以通过在参数中指定参数文件radiomics-parameter-file-label--param 或者添加定义提取--setting来完成。 使用python进行特征提取12345678910111213141516import osimport SimpleITK as sitkimport sixfrom radiomics import featureextractor, getTestCase dataDir = '/path/to/pyradiomics' # 存放有image和mask的文件夹imageName, maskName = getTestCase('brain1', dataDir) # 将iamge路径和mask路径分开存储params = os.path.join(dataDir, "examples", "exampleSettings", "Params.yaml") # 参数文件路径extractor = featureextractor.RadiomicsFeaturesExtractor(params) # 使用参数文件实例化特征提取器类result = extractor.execute(imageName, maskName)for key, val in six.iteritems(result): print("\t%s: %s" %(key, val)) # 进行特征提取 3D slicer在3D slicer中可以添加“Radiomics”扩展，按照要求导入文件，即可输出特征文件。]]></content>
      <categories>
        <category>医学图像</category>
      </categories>
      <tags>
        <tag>radiomics</tag>
        <tag>医学图像</tag>
        <tag>特征提取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python库:pathlib和os的区别]]></title>
    <url>%2Fp%2F787a.html</url>
    <content type="text"><![CDATA[pathlib作为python3的新特性之一，对于路径会创造Path对象，使对路径的操作更方便。之前在别人的代码里见识到了pathlib的优点，现在希望用pathlib来代替os库来完成路径的操作。 目前我主要用到os的地方有以下几个： 路径拼接 新建文件夹 文件遍历 获得子级文件的路径 重命名文件夹 pathlib的优势 pathlib的不足 路径拼接 pathlib采用了斜线直接连接的方式， 1234import ospath = 'root'dir = 'test'target_path = os.path.join(path,dir) # 'root/test' 123from pathlib import Pathp1 = Path('root')p2 = p1/'test' 新建文件夹 在使用os库的时候，新建文件夹之前需要判断文件夹是否存在，如果文件夹已存在，创建文件夹时会报错。 1234import osif not os.path.exists(path): os.mkdir(path) # 创建一个文件夹 os.makedirs(path) # 创建多个文件夹 123from pathlib import Pathp = 'XXX'p.mkdir(parents=True) # parents=True会创造路径中间缺少的文件夹 文件遍历 1234import osfor root, dirs, files in os.walk(path): for file in files: temp_path = os.path.join(root, file) pathlib在遍历时结合了glob,在检索时还能定制检索的要求。 123456from pathlib import Pathbase_dir = 'XXX'p = Path(base_dir)# 遍历获取改文件夹下面所有的文件file_list = p.glob('**/*') for f in file_list: 获得子级文件的路径 1234import osos.listdir()from pathlib import Path Path.iterdir() 重命名文件夹 12345678910import osos.rename(src, dst)# src -- 要修改的目录名# dst -- 修改后的目录名from pathlib import Path p = Path(src)p.rename(dst)# 即pathlib主要是通过对象来完成功能 pathlib的优势 在建立path对象之后，可以调用路径的组件直接获得路径的信息： 123456789101112131415161718192021222324252627Path. parts #获得路径的各个组件PurePath('/usr/bin/python3').parts('/','usr', 'bin', 'python3')######################################PurePath. drive #获得路径的驱动PureWindowsPath('c:/Program Files/').drive'c:'########################################PurePath. parents #路径的父级p = PureWindowsPath('c:/foo/bar/setup.py')p.parents[0]PureWindowsPath('c:/foo/bar')p.parents[1]PureWindowsPath('c:/foo')p.parents[2]PureWindowsPath('c:/')#########################################PurePath. name #路径的最终路径PurePosixPath('my/library/setup.py').name'setup.py##########################################PurePath. suffix #路径的文件拓展名PurePosixPath('my/library/setup.py').suffix'.py' pathlib一些方法在实现时调用了os的方法，所以很多输出他们是一样的。 123456@classmethoddef cwd(cls): """Return a new path pointing to the current working directory (as returned by os.getcwd()). """ return cls(os.getcwd()) 但是使用 Path 对象可以使代码更加明确。比如 123456from datetime import datefrom pathlib import Pathperson = &#123;"name": "Trey Hunner", "location": "San Diego"&#125;pycon_2019 = date(2019, 5, 1)home_directory = Path('/home/trey') 就会比下面的代码更直观。 123person = '&#123;"name": "Trey Hunner", "location": "San Diego"&#125;'pycon_2019 = "2019-05-01"home_directory = '/home/trey' pathlib的不足之处 pathlib缺少对文件夹进行复制粘贴的功能，相应操作需要导入shutil才能完成 pathlib缺少os.chdir，无法改变当前的工作目录 最后是一些os和pathlib的对照语法。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>os</tag>
        <tag>pathlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优化网站打开的速度]]></title>
    <url>%2Fp%2F7c7e.html</url>
    <content type="text"><![CDATA[在加了一些功能之后发现网络打开太慢了，尝试一些能加速打开的方法。 首先测试一下什么都不做时候的效果 测试计时用的是chrome的web调试中的Network加载时间 初次打开时间在3秒左右，之后重复刷新时间在1.2s左右 尝试CDN加速使用CloudFlare来修改DNS 测试打开时间依旧在3s以上 并没有明显变化，由于CloudFlare使用的不是大陆的服务器，可能反而会导致速度更慢，暂时放弃这种方法 取消加载动画next主题自带加载动画，会在网站感官上变得很慢，先去掉动画尝试一下效果 12motion: enable: false 图片懒加载在使用到图片时才进行加载，加快网站打开速度 待尝试]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>cdn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客更新]]></title>
    <url>%2Fp%2Fea1c.html</url>
    <content type="text"><![CDATA[在之前的基础上对博客添加一点优化 包括博文置顶、添加当前浏览进度、加入live2d、添加评论功能、添加访问人数 博文置顶安装插件 12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 然后在需要置顶的文章上加入top，如 12345---title: 2018date: 2018-10-25 16:10:03top: 10--- 添加当前浏览进度修改themes/*/_config.yml，把 false 改为 true： 12345# Back to top in sidebarb2t: true# Scroll percent label in b2t buttonscrollpercent: true 加入live2d安装插件 1npm install --save hexo-helper-live2d 将以下代码添加到主题配置文件_config.yml，修改&lt;你喜欢的模型名字&gt;： 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-&lt;你喜欢的模型名字&gt; display: position: right width: 150 height: 300 mobile: show: true 建配置文件 在站点目录下建文件夹live2d_models， 再在live2d_models下建文件夹&lt;你喜欢的模型名字&gt;, 再在&lt;你喜欢的模型名字&gt;下建json文件：&lt;你喜欢的模型名字&gt;.model.json 安装模型。在命令行（即Git Bash）运行以下命令即可： npm install –save live2d-widget-model-&lt;你喜欢的模型名字&gt; 在命令行（即Git Bash）运行以下命令， 在http://127.0.0.1:4000/查看测试结果: hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 然后因为太丑了取消掉了。 添加评论功能这是我参考的博客 然后参考着就放弃了，然后选择了Valine 比起必须备案的畅言，valine只需要注册就能得到app ID，十分方便，评论时也无需登录 12345678910valine:enable: trueappid: xxxxxx # 填写 leancloud appidappkey: xxxxxx # 填写 leancloud appkeynotify: false #verify: false # Verification codeplaceholder: # comment box placeholder 默认的评论展示avatar: mm # gravatar styleguest_info: nick,mail,link # custom comment headerpageSize: 10 # pagination size 添加访问人数next主题自带busuanzi，只需要在主题配置文件中找到busuanzi，并将False改为true即可。 12345678busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公式、图片输入]]></title>
    <url>%2Fp%2F91ec.html</url>
    <content type="text"><![CDATA[目前新建的博客中图片和公式输入还存在问题。 由于在引擎渲染生成网页的时候，语法和markdown语法冲突，可以通过在主题（Theme）中开启 MathJax 开关来避免这个问题 进入到主题目录，找到 _config.yml 配置问题，把 math 默认的 false 修改为true，具体如下： 12345678910math: enable: true # Default(true) will load mathjax/katex script on demand # That is it only render those page who has &apos;mathjax: true&apos; in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: true engine: mathjax #engine: katex 然后在文章开头加入mathjax: true 123456---title: index.htmldate: 2018-07-05 12:01:30tags:mathjax: true-- $$\begin{array}{c}{f=u n} \ {p(f | u, L)=\frac{2 L^{L}}{\Gamma(L) u^{2 L}} f^{2 L-1} e^{-\frac{L^{2}}{u^{2}}}}\end{array}$$ 公式测试输入成功 直接保存本地图片无法在网页上显示，解决方法有两种： 使用图床 选择随意一个图床工具，我这里用的cheveretocom，上传你的图片，然后选择markdown链接，将链接放到![](签名链接)中，就可以正常显示。 此外还有各种工具能更快的做这步，比如mac下的imic，windows下的mpic 对博客中用到的图片把保存在对应文件夹下 首先确认将_config.yml 中的 post_asset_folder修改为true 之后在hexo n [postname]的时候会自动生成一个同名文件夹 然后在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save 这样的目录结构（目录名和文章名一致），只要使用 ![logo](XX/logo.jpg) 就可以插入图片。其中[]里面不写文字则没有图片标题。 但是图片测试为什么没有成功呢。。]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客]]></title>
    <url>%2Fp%2Fdad8.html</url>
    <content type="text"><![CDATA[前言通过hexo搭建个人博客主要有下面三个部分内容 安装hexo，生成基础文件格式 选择使用博客主题，修改配置文件 将文件上传到github上，然后通过域名解析连接到个人域名上 安装配置文件1.安装Node.js123sudo add-apt-repository ppa:chris-lea/node.jssudo apt-get updatesudo apt-get install nodejs 2.安装Git1sudo apt-get install git 3.安装hexo1sudo npm install hexo -g 初始你博客的根目录（或者cd到指定目录下，然后执行hexo init） 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 此时就会生成如下路径的文件夹，到这一步hexo的安装任务就完成了 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 这里解释一下各个文件夹的作用：config.yml博客的配置文件，博客的名称、关键词、作者、语言、博客主题…设置都在里面。package.json应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。scaffoldsscaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容sourcesource是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。themes放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。 修改配置文件 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项 。为了描述方便，在以下说明中，将前者称为站点配置文件， 后者称为主题配置文件。以下所有终端执行的命令都在你的Hexo根目录下 每一个冒号后的修改都需要添加空格 对于配置文件的修改可以通过12hexo s #默认端口为4000 # hexo s -p xxxx # 指定端口 来调试，访问’http://localhost:4000/&#39; 就能看到修改后的结果，有些修改需要重新开启调试以后才能看出变化 修改 站点配置文件12345678# Sitetitle: wuyu&apos;s Blog subtitle: try. description:keywords:author: wulanguage: zh-Hans # 选择语言，简体中文为zh-Hanstimezone: 对于默认生成的站点文件并不需要大量修改，而且可以通过安装第三方库的方式增加网站功能。 自己添加的功能添加头像12# 添加头像avatar: /avatar/header.jpeg # avatar文件夹需要保存在source文件夹下 12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 添加站点地图站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站 安装插件 打开hexo目录下的dos命令行，分别安装百度和google插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 添加本地站内搜索需要安装依赖库12npm install --save hexo-generator-searchnpm install hexo-generator-searchdb --save 然后在站点配置文件添加123search: path: search.xml field: post 最后打开 主题配置文件 找到Local search，将enable设置为true 用于生成RSS12# Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 用于生成文章和站点的统计字数安装依赖库1npm install --save hexo-symbols-count-time 然后在站点配置文件添加12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true 修改 主题配置文件更换主题按照喜好选择自己想用的主题，这里我选择NexT主题 1git clone https://github.com/theme-next/hexo-theme-next github上存在两个版本的next，上面时新版的next将下载下来的主题重命名为next， 放入你hexo的根目录下的themes文件夹下将站点配置文件中的theme修改为next 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 更换主题风格在next下有四种风格，通过取消注释来选择你想使用的风格，这里我才用了Gemini风格，但四种风格差异不大 12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 选择menu在menu下可以选择你可点选页面，tagsh和categories对于博客整理归类比较有用123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 此时categories页面还没有生成，点击时会返回 cant get tags错误。我们需要通过以下命令增加page 1hexo new page categories 该命令将在source下生成categories文件夹，包含了index.md文件,之后的博客如果填写categories就会自动分类。 控制首页展示文章长度在博文中加入 1&lt; !--more--&gt; 来控制首页显示字符长度 也可以通过修改主题配置文件中的auto_excerpt来进行修改 12345# Automatically Excerpt. Not recommand.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 方法1较为灵活，方法2能控制每个文章长度统一但是会把完整的句子打断显示为省略号，各有利弊 将文件配置到github以及个人域名搭建github库第一步： 需要有github账号 新建一个仓库项目名一定要是用户名.github.io的形式第二步：安装hexo-deployer-git（不然会出现ERROR Deployer not found: git） 1npm install hexo-deployer-git --save 第三步： 配置你hexo博客根目录下的_config.yml文件，需要修改的地方有两个 123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://githubname.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults: 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:githubname/githubname.github.io.git branch: master git配置在使用hexo d之前如果没有配置过git,需要在终端中输入 1ssh-keygen -t rsa -C &apos;githubname&apos; 然后连续回车，如果出现 1234Generating public/private rsa key pair.Enter file in which to save the key (/home/deepliver/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: 说明没有问题，继续回车会出现12Your identification has been saved in /User/username/.ssh/id_rsa.Your public key has been saved in /User/username/.ssh/id_rsa.pub. 此时输入 1cat /home/deepliver/.ssh/id_rsa.pub 会出现 ssh-rsa …将这些字符全部复制到github的setting中的SSH即完成配置 上传至github库然后在博客文件夹的根目录下输入 123$ git config --global user.name &apos;githubname&apos;$ git config --global user.email &apos;email@example.com&apos;$ hexo d 就能将文件夹上传到先前创建的XX.github.io项目中,此时访问这个网站就能看到你的博客内容 个人域名 购买域名（任意网站，如阿里云） 获得IP 输入ping 用户名.github.io 解析域名添加两条记录，选择记录类型A，第一个主机类型填@， 记录值为上一部得到的IP值第二个主机类型为www，其余不变 在github上新建CNAME文件内容为你所购买的域名 到此搭建过程基本完成，可以通过各种第三方库来完善你的博客。 最后一步之后就可以直接在本地的博客文件夹下通过 12345hexo n &quot;新的文章名&quot; # 就会在source/_posts下新建一个md文件# 写完博客之后hexo cleanhexo g # 生成新的静态页面hexo d # 将内容同步到github上 来新建博客～选择tags和categories的方式为在默认的—-区域中添加 123456tags: - tag1 - tag2# 或者tags: [tag1, tag2]categories: xxx 由于每次上传值github的过程时生成新的静态页面的过程，所以github上的CNAME文件可能被替代，以下是几种解决方法： 方法一：每次 hexo d 之后，就去 GitHub 仓库根目录新建 CNAME文件 方法二：在 hexo g 之后， hexo d 之前，把CNAME文件复制到 “\public\” 目录下面，里面写入你要绑定的域名。 方法三（推荐）：将需要上传至github的内容放在source文件夹，例如CNAME、favicon.ico、images等，这样在 hexo d 之后就不会被删除了。 方法四：通过安装插件实现永久保留 1$ npm install hexo-generator-cname --save 之后在_config.yml中添加一条 12Plugins:- hexo-generator-cname 需要注意的是：如果是在github上建立的CNAME文件，需要先clone到本地，然后安装插件，在deploy上去即可。CNAME只允许一个域名地址。此时_config.yml中url也需要修改成你所购买的域名.]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>wuyu</tag>
      </tags>
  </entry>
</search>
